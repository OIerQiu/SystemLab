第一个任务：memory allocator
观察源码，发现全局共用一个kmem锁，因此按照题目意思，改为使用NCPU个kmem锁。
根据当前的CPU选择对应的锁，在获取CPU编号前后执行push_off()和pop_off()即可。
唯一需要注意的是kalloc函数，需要考虑可能从别人那边拿内存块的情况，代码按照源码依样画葫芦即可。
写完后挂了一次，查了半天，发现漏了个pop_off()。

第二个任务: buffer cache
比较复杂，需要支持高并发地使用buffer_cache。
根据提示，我们可以用hash来管理每个block，hash函数选取了将编号模13。
对每个桶设置一个锁，和一个虚拟buf，再为全局设置一个锁，用来处理bucket间“借”buf的情况。
对于每个buf，由于不再使用LRU，prev便没有必要了，但是要实现类似LRU的效果，所以增加了一个时间戳。
由于不再使用LRU，init函数被简化的比较多，其他函数的实现也较为简单，注意引用计数归零时重置时间戳就行。
主要是kget函数，要实现并行的同时还要保证不会产生错误。因此，不妨将编号对应哈希桶的锁从头占用到底，防止出错。
先考虑编号对应哈希桶内是否已经有相同buf，在考虑是否还有buf没被分配给任何一个桶（需锁上全局锁）。
最后再考虑从别的桶里拿走buf，处于对效率和公平性的综合考虑，用一个和LRU类似的算法：
每个桶都找过去（需锁上别的桶对应的锁），如果在某个桶中找到了可用的buf，则在那个桶中找最长时间未被使用的来拿走就行。
同时，每次从编号上离这个桶更近的桶中开始找即可。
涉及的锁非常多，注意锁的释放即可（因为这个错了一次）。
